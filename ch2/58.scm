(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (variable? exp) (symbol? exp))
(define (same-variable? v1 v2) (eq? v1 v2))

(define (make-sum a1 a2 . ak)
  (define (helper a1 a2) ;; this is the original make-sum
    (cond ((=number? a1 0) a2)
	  ((=number? a2 0) a1)
	  ((and (number? a1) (number? a2)) (+ a1 a2))
	  (else (list a1 '+ a2))))
  (let ((all (cons a1 (cons a2 ak))))
    (let ((num (fold-right + 0 (filter number? all)))
	  (not-nums (filter (lambda (x) (not (number? x))) all)))
      (if (null? not-nums)
	  num
	  (fold-right helper 0 (cons num not-nums))))))

(define (sum? exp)
  (and (list? exp) (not (null? (filter (lambda (x) (eq? x '+)) exp)))))

(define (addend sum)
  ;; retains those elements of the list before the given symbol
  (define (antimemq symb list)
    (cond ((null? list) #f)
	((eq? (car list) symb) '())
	(else (cons (car list)
		    (antimemq symb (cdr list))))))
  (let ((candidate (antimemq '+ sum)))
    (if (= (length candidate) 1)
	(car candidate)
	candidate)))

(define (augend sum)
  (let ((candidate (cdr (memq '+ sum))))
    (if (= (length candidate) 1)
	(car candidate)
	candidate)))

(define (negate exp)
  (if (number? exp)
      (- exp)
      (list '- exp)))
(define (negation? exp)
  (and (list? exp) (eq? (car exp) '-) (null? (cddr exp))))
(define (negated exp) (cadr exp))

(define (make-difference m s) ;; just do it
  (cond ((=number? m 0) (negate s))
	((=number? s 0) (negate m))
	((and (number? m) (number? s)) (- m s))
	(else (list m '- s))))
(define (difference? exp)
  (and (list? exp) (eq? (cadr exp) '-)))
(define (minuend d) (car d))
(define (subtrahend d) (caddr d))

(define (make-product a1 a2 . ak)
  (define (helper m1 m2) ;; the original make product
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	  ((=number? m1 1) m2)
	  ((=number? m2 1) m1)
	  ((and (number? m1) (number? m2)) (* m1 m2))
	  (else (list m1 '* m2))))
  (let ((all (cons a1 (cons a2 ak))))
    (let ((num (fold-right * 1 (filter number? all)))
	  (not-nums (filter (lambda (x) (not (number? x))) all)))
      (if (null? not-nums)
	  num
	  (fold-right helper 1 (cons num not-nums))))))

(define (product? exp)
  (and (list? exp) (not (null? (filter (lambda (x) (eq? x '*)) exp)))))

(define (multiplier p)
  (define (thelastofus symb list)
    (cond ((null? list) #f)
	  ((eq? symb (cadr list)) (car list))
	  (else (thelastofus symb (cdr list)))))
  (thelastofus '* p))
(define (multiplicand p)
  (let ((candidate (cdr (memq '* p))))
    (if (= (length candidate) 1)
	(car candidate)
	candidate)))

(define (make-quotient d1 d2)
  (cond ((=number? d2 0)
	 (error "MAKE-QUOTIENT" "The divisor is zero" d2))
	((=number? d2 1) d1)
	((and (number? d1) (number? d2)) (/ d1 d2))
	(else (list d1 '/ d2))))
(define (quotient? exp)
  (and (list? exp) (eq? (cadr exp) '/)))
(define (dividend q) (car q))
(define (divisor q) (caddr q))

(define (make-exponentiation base exponent)
  (cond ((or (=number? base 0)
	     (=number? base 1)
	     (=number? exponent 1)) base)
	((=number? exponent 0) 1)
	((and (number? base) (number? exponent))
	 (expt base exponent))
	(else (list base '^ exponent))))
(define (exponentiation? exp)
  (and (list? exp) (eq? (cadr exp) '^)))
(define (base expt) (car expt))
(define (exponent expt) (caddr expt))

(define (make-log antilog)
  (if (number? antilog)
      (log antilog)
      (list 'log antilog)))
(define (log? exp)
  (and (list? exp) (eq? (car exp) 'log)))
(define (antilog log) (cadr log))

(define euler (exp 1))

;; It's still ugly as hell, so I no longer have the
;; motivation to implement trig functions
(define (deriv exp var)
  (cond ((number? exp) 0)
	((variable? exp)
	 (if (same-variable? exp var) 1 0))
	((sum? exp)
	 (make-sum (deriv (addend exp) var)
		   (deriv (augend exp) var)))
	((negation? exp)
	 (negate (deriv (negated exp) var)))
	((difference? exp)
	 (make-difference (deriv (minuend exp) var)
			  (deriv (subtrahend exp) var)))
	((product? exp)
	 (let ((plier (multiplier exp))
	       (plicand (multiplicand exp)))
	   (make-sum
	    (make-product plier (deriv plicand var))
	    (make-product (deriv plier var) plicand))))
	((quotient? exp)
	 (let ((dividend (dividend exp))
	       (divisor (divisor exp)))
	   (make-quotient
	    (make-difference
	     (make-product (deriv dividend var) divisor)
	     (make-product dividend (deriv divisor var)))
	    (make-exponentiation divisor 2))))
	((exponentiation? exp)
	 (let ((base (base exp))
	       (expt (exponent exp)))
	   (let ((logbase (make-log base)))
	     (make-product
	      (make-exponentiation euler (make-product expt logbase))
	      (deriv (make-product expt logbase) var)))))
	((log? exp)
	 (let ((antilog (antilog exp)))
	   (make-quotient (deriv antilog var) antilog)))
	(else
	 (error "DERIV" "Unknown expression type" exp))))
